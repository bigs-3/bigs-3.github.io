{"./":{"url":"./","title":"Introduction to Relation network","keywords":"","body":"Introduction to Relation network Welcome to the Relation document page! Today, users are quietly allowing addresses to become data silos while performing multiple on-chain activities. The effective information hidden behind the massive public address cannot be extracted effectively, and it is difficult to build a truly close social bond between users. Following the development trend of Web3, Relation will make a subversive change to this situation by using the social way of tagging. Base is a protocol based on Web3 social Relation to all decentralized middleware application, support for multiple application scene, committed to build social networks in the chain of search engines and infrastructure, to help individuals and business users use open, security and comprehensive social network underlying data service, customized intelligent contract agreement, In this way, we can find and edit friends and groups freely in the world of Web3, and realize the social network on the native chain. Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 11:55:40 "},"about-relation-network.html":{"url":"about-relation-network.html","title":"About Relation network","keywords":"","body":"About Relation network Relation Network aims to enable users to find and edit friends and groups in the Web3 world. The design includes several key parts, including contract, middleware, plug-in and dApp. Provide customized services for individual and enterprise users, enabling Web3 scenarios in DeFi, GameFi, NFT and other domains. Relation Network is composed of six core parts: data layer, node contract, label indexer, relationship contract, instant messaging indexer and network indexer. It realizes API integration and has outstanding features of full process, standardization, authenticity, full coverage, immediacy and security Data layer: The underlying infrastructure layer. The entire Data Layer adopts a two-layer architecture design, including the Blockchain Sync Layer and the Data Provider Layer. Network node storage: Store huge amounts of social data and address tag data on user chains, including Consumer/Dapp Developer, Indexer, Delegator, Arbitrator, Fisherman, and Relation Council. Jointly complete node governance. Label indexer: It classifies and adds labels to addresses on the Ethereum chain, including individuals, institutions and smart contracts of specific DApps, through automatic recognition of algorithms, so as to draw vivid and accurate user portraits, and realize indexing and filtering of personalized target addresses or address books. Relationship contract: establish social relationship network based on target address book such as friends and groups through smart contract, and automatically record and analyze social relationship to form specific classification labels, so as to help users further insight into the dynamic between addresses on the chain. Instant messaging indexer: a breakdown of activity on the chain at the second level after execution. Whether it's a startup or an existing product, the ability to quickly get real-time results of on-chain activities after submitting requirements. Network indexer: provide safe and efficient data query for enterprise users, so as to carry out targeted advertising and accurate marketing Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 11:55:40 "},"node/indexing-service-node.html":{"url":"node/indexing-service-node.html","title":"Indexing Service Node","keywords":"","body":"Indexing Service Node Introduction Indexing service node. This node responds the GraphQL query request sent by the user and checks the user's subscription status in the node, determines if it has expired, and queries from the connected data analysis engine to return the corresponding data. When a user sends a request, they need to attach a certificate signed by EIP712 to prevent impersonation, which also serves as a node query and subscription credentials. Roles Developer Create http with graphql queries in a dapp interact with the indexer Indexer Operate a node to serve graphql queries and interact with the data engine to response the queries Launch requirements The project has a built-in one-click launch script based on docker-compose, and the deployment method can be modified as needed.\\ \\ The following environment variables need to be configured: APP_HASURA_SECRET: random string used for secure access of nodes in the hasura graphql engine, for example: ** hyYE3it4jW7V43Ez.** PG_DATABASE_URL: The URL of the data analysis engine database, for example: postgresql://postgres@postgres@127.0.0.1:5432/postgres Note: If username and password containing '@' special characters need to be UrlEncoded Lunch env APP_HASURA_SECRET=hyYE3it4jW7V43Ez \\ PG_DATABASE_URL=postgresql://postgres@postgres@127.0.0.1:5432/postgres \\ docker-compose up -d Developer's Guide The client (user) signs with eip712 and attaches the query graphql statement For example, using nodejs to construct a signature const wallet = new Wallet(\"291cde1766b88830c50ee3b3d61206d0f46a5fa4242af228d4adcb869a13091e\"); const domain = { name: 'Relation Indexer Receipt', version: '1', chainId: 1, verifyingContract: '0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc' }; const types = { Receipt: [ {name: 'address', type: 'address'}, {name: 'nonce', type: 'string'}, {name: 'timestamp', type: 'uint256'} ] }; const value = { address: wallet.address, nonce: crypto.randomBytes(16).toString('base64'), timestamp: Math.floor(Date.now() / 1000) }; const rawSignature = await wallet._signTypedData(domain, types, value); const signature = ethers.utils.splitSignature(rawSignature); To query which tags an address has, we can construct such json body within http request: { \"query\": \"query { addressTags(address: \\\"0x0d8775f648430679a709e98d2b0cb6250d2887ef\\\"){ tag tokenAddress tokenName tokenSymbol } }\", \"receipt\": { \"address\": \"0xAEA3B807e5abA2920beC32a5c3Ca1C9dA1cBa2a4\", \"nonce\": \"dBcZ+sat2ljoOFvyuokXvA==\", \"timestamp\": 1639706018, \"r\": \"0xa901c868879f05a469684794fed3713530a1e0d823a0132a67c0ac7a175b162f\", \"s\": \"0x7075d933fb3c4b75544d27540e859e91a3188060962104c1f0179e870f281130\", \"v\": 28 } } The above search engine supports many ERC20 tokens, such as: Token Name oneinch_balance (1inch) mana_balance aave_balance sand_balance axs_balance uni_balance By default, you can query these fields separately. As example, to query the addresses of 'mana' with a balance within a certain range you would use: query MyQuery { tag(where: {mana_balance: {_gt: 100}, _and: {mana_balance: {_lt: 1000}}}) { address } } Users can also freely combine fields to construct new queries, such as taking the sum of all the above token balances as a new total_balance field, and then querying some account addresses which total_balance is within a certain range: Visual walkthrough Open hasura's console by set the environment variables HASURA_GRAPHQL_ENABLE_CONSOLE=true As shown below, create a new VIEW Use the following “query” to query which accounts’ total_balance is in the range 0 - 10000 query MyQuery { tag_with_total_balance(where: {total_balance: {_gt: 0}, _and: {total_balance: {_lt: 100000}}}) { address total_balance } } Configuration with file settings: Install hasura cli, you can refer to the Hasura CLI | Hasura GraphQL Docs Run the hasura migrate create \\ --database-name \\ The corresponding up.sql will be generated in the migrations folder Write the corresponding create view SQL: CREATE OR REPLACE VIEW address_with_total_balance AS SELECT address, COALESCE(oneinch_balance, 0) + COALESCE(mana_balance, 0) + COALESCE(aave_balance, 0) + COALESCE(sand_balance, 0) + COALESCE(axs_balance, 0) + COALESCE(uni_balance, 0) AS total_balance Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 13:53:01 "},"node/data-analysis-node.html":{"url":"node/data-analysis-node.html","title":"Data Analysis Node","summary":"LabelNode","keywords":"","body":"Data Analysis Node Prerequisites To build and run this node you need to have the following installed on your system: Rust (latest stable) – How to install Rust Note that rustfmt, which is part of the default Rust installation, is a build-time requirement. PostgreSQL – PostgreSQL Downloads IPFS – Installing IPFS For Ethereum network data, you can either run your own Ethereum node or use an Ethereum node provider of your choice. Running a Blockchain Sync Layer This is a quick example to show a working blockchain sync layer. Install IPFS and run ipfs init followed by ipfs daemon. Install PostgreSQL and run initdb -D .postgres followed by pg_ctl -D .postgres -l logfile start and createdb graphtest. If using Ubuntu, you may need to install additional packages: sudo apt-get install -y clang libpq-dev libssl-dev pkg-config build docker image ./docker/build.sh Command-Line Interface USAGE: graph-node [FLAGS] [OPTIONS] --ethereum-ipc --ethereum-rpc --ethereum-ws --ipfs --postgres-url FLAGS: --debug Enable debug logging -h, --help Prints help information -V, --version Prints version information OPTIONS: --admin-port Port for the JSON-RPC admin server [default: 8020] --elasticsearch-password Password to use for Elasticsearch logging [env: ELASTICSEARCH_PASSWORD] --elasticsearch-url Elasticsearch service to write subgraph logs to [env: ELASTICSEARCH_URL=] --elasticsearch-user User to use for Elasticsearch logging [env: ELASTICSEARCH_USER=] --ethereum-ipc Ethereum network name (e.g. 'mainnet'), optional comma-seperated capabilities (eg full,archive), and an Ethereum IPC pipe, separated by a ':' --ethereum-polling-interval How often to poll the Ethereum node for new blocks [env: ETHEREUM_POLLING_INTERVAL=] [default: 500] --ethereum-rpc Ethereum network name (e.g. 'mainnet'), optional comma-seperated capabilities (eg 'full,archive'), and an Ethereum RPC URL, separated by a ':' --ethereum-ws Ethereum network name (e.g. 'mainnet'), optional comma-seperated capabilities (eg `full,archive), and an Ethereum WebSocket URL, separated by a ':' --http-port Port for the GraphQL HTTP server [default: 8000] --ipfs HTTP address of an IPFS node --node-id a unique identifier for this node [default: default] --postgres-url Location of the Postgres database used for storing entities --subgraph name and IPFS hash of the subgraph manifest --ws-port Port for the GraphQL WebSocket server [default: 8001] For Example docker run -it \\ -p 8000:8000 \\ -p 8001:8001 \\ -p 8020:8020 \\ -p 8030:8030 \\ -e postgres_host=10.0.191.31 \\ -e postgres_port=5432 \\ -e postgres_user=graphtest \\ -e postgres_pass=graphtest \\ -e postgres_db=graphtest \\ -e ipfs=10.0.191.31:5001 \\ -e ethereum=privnet:http://10.0.191.31:8545 \\ -e SUBGRAPH_ALLOWLIST_FILEPATH='/allowlist.json' \\ graph-node SUBGRAPH_ALLOWLIST_FILEPATH (allowlist.json) { \"allowlist\" : [ \"0xd26114cd6ee289accf82350c8d8487fedb8a0c07\", \"0x209c4784ab1e8183cf58ca33cb740efbf3fc18ef\", \"0xdac17f958d2ee523a2206206994597c13d831ec7\", \"0x36928500bc1dcd7af6a2b4008875cc336b927d57\", \"0xe0bdaafd0aab238c55d68ad54e616305d4a21772\", \"0x798d1be841a82a273720ce31c822c61a67a601c3\", \"0xd13c7342e1ef687c5ad21b27c2b65d772cab5c8c\", ] } Running Data Provider Layer ** 1. Set the following environment variables: RELATION_DB_HOST: Postgre DB host RELATION_DB_PORT: Postgre DB port RELATION_DB_NAME: Postgre DB username RELATION_DB_PWD: Postgre DB password 2. Install packages: npm install 3. run node npm run dev Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 13:53:01 "},"node/supported-networks.html":{"url":"node/supported-networks.html","title":"Supported Networks","keywords":"","body":"Supported Networks Ethereum BSC Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 11:55:40 "},"engines/label-engines.html":{"url":"engines/label-engines.html","title":"Label Engines","summary":"Graphql reference for Label Engines.","keywords":"","body":"Label Engines Base Labels addressTagsInputoutputQuery an address and it's owned tags Name Descriotion address The address to query Name Value tag Name of label tokenName Name of token tokenSymbol Symbol of token tokenAddress Address of token examplequery { addressTags(address: \"0x111111111117dc0aa78b770fa6a738034120c302\") { tag tokenName tokenSymbol tokenAddress } } Track Labels NFTGameFiNFT Tokens Properties aave balance oneinch (1inch) vol uni \\ Query Balance:query { tag(limit: 10, where: {aave_balance: {_gt: \"0\"}}) { address } } \\ Query Volume:query { tag(limit: 10, where: {aave_vol: {_gt: \"0\"}}) { address } } Tokens Properties sand balance mana vol axie Query Balance:query { tag(limit: 10, where: {sand_balance: {_gt: \"0\"}}) { address } } \\ Query Volume:query { tag(limit: 10, where: {sand_vol: {_gt: \"0\"}}) { address } } Properties Description nft_collector Hold nft ignore nft category cryptopunks_balance Balance of cryptopunks boredapeyachtclub_balance Balance of boredapeyachtclub uncommon_nft_collector Top 10% of NFT trading volume rare_nft_collector Top 2.5% of NFT trading volume epic_nft_collector Top 1% of NFT trading volume legendary_nft_collector Top 0.1% of NFT trading volume Example:query { tag(limit: 10, where: {nft_collector: {_eq: true}}) { address } } query { tag(where: {cryptopunks_balance: {_gte: \"1\"}}, limit: 10) { address } } Project Label Uniswapquery { tag(where: {uni_balance: {_gt: \"0\"}}) { address } } Category Label swapstakeLPquery { tag(where: {_or:[{oneinch_swap: {_eq: true}}, {uniswap_swap: {_eq: true}}]}) { address } } query { tag(where: {aave_stake: {_eq: true}}) { address } } query { tag(where: {uniswap_lp: {_eq: true}}, limit: 10) { address } } Total Statistics Label address_with_all Properties Description address address of user activity activity of user transactions total_nft___balance total balance of nft total_nft_vol total volume of nft total_token_balance total balance of erc20 tokens total_token_vol total volume of erc20 tokens Example:query { address_with_all(where: {total_nft_balance: {_gt: 100}}, limit: 10) { address, total_nft_balance } } Wallet Labels tag Name Description erc20_millionaire Erc20 balance is greater than million erc20_billionaire Erc20 balance is greater than billion eth_millionaire Eth balance is greater than million eth_billionaire Eth balance is greater than billion \\ Example:query { tag(where: {erc20_millionaire: {_neq: \"{}\"}}, limit: 10) { address } } Special Labels tag Name Description high_activity_trade FlashBoys: Traders, high-frequency trading wallets on DEX \\ Example:query { tag(where: {high_activity_trader: {_eq: true}}, limit: 10) { address } } Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-23 09:58:21 "},"engines/relation-engines.html":{"url":"engines/relation-engines.html","title":"Relation Engines","summary":"Graphql reference for Relation Engines.","keywords":"","body":"Relation Engines Friend friend listfriend requetsquery { relation(where: {to: {_eq: \"0x0a0b364093cb37787827e210806f50c30ce4e192\"}}) { from } } query { relation_request(where: {to: {_eq: \"0x0a0b364093cb37787827e210806f50c30ce4e192\"}, status: {_eq: \"1\"}}) { from } } Group Properties Description name The name of group desc The description of group owner The owner of group query groupget group membersquery MyQuery { group(where: {desc: {_ilike: \"%美团%\"}}) { name desc } } query { group(where: {group_id: {_eq: \"1\"}}) { members } } Group Manager Properties Description group_id The ID of group manager The manager of group query managerquery { group_manager(where: {group_id: {_eq: \"1\"}}) { manager } } Group Member Request Properties Description group_id The ID of group requester The address of requester status The status of request query group member requetsquery { group_member_request(where: {group_id: {_eq: \"1\"}}) { group_id requester } } Group Manager Request Properties Description group_id The ID of group requester The address of requester status The status of request query group manager requetsquery { group_manager_request(where: {group_id: {_eq: \"1\"}}) { group_id requester } } Statistical friends countgroup members countquery { relation_aggregate(where: {is_friend: {_eq: true}, _and: {from: {_eq: \"0x0a0b364093cb37787827e210806f50c30ce4e192\"}, _or: {to: {_eq: \"0x0a0b364093cb37787827e210806f50c30ce4e192\"}}}}) { aggregate { count(columns: is_friend) } } } query MyQuery { group_member_aggregate { aggregate { count(columns: member) } nodes { member } } } Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-23 09:55:39 "},"contracts/friend-relation.html":{"url":"contracts/friend-relation.html","title":"Friend Relation","summary":"API reference for Relation Friend Contract.","keywords":"","body":"Friend Relation Index Methods Name Description requestFriend Request a friend receiveFriendRequest Receive a friend request rejectFriendRequest Reject a friend request blockUser Block a user unblockUser Unblock a user removeFriend Remove a friend isFriend If two users are friends Events Name Description FriendRequested Emitted from a friend contract when a user request a friend FriendRequestedWithGift Emitted from a friend contract when a user request a friend with a gift FriendRequestReceived Emitted from a friend contract when a friend request received from a user FriendRequestRejected Emitted from a friend contract when a user reject a friend request UserBlocked Emitted from a friend contract when a user block someone UserUnblocked Emitted from a friend contract when a user unblock someone FriendRemoved Emitted from a friend contract when a user remove a friend Methods Below you'll find each helper explained in greater detail alongside respective implementation examples to help you leverage these methods once you start building your own relation contract. /** * @Param receiver Request Receiver */ function requestFriend(address receiver) external After the function signature and a short description, two code examples are provided, one focusing on the exact usage of the method and one where the helper is presented in the context of a full contract. /** * @param receiver Request receiver * @param gift Some RNT as gift to receiver. Can be zero. */ function requestFriendWithGift(address receiver, uint256 gift) external requestFriend function requestFriend( address receiver ) examplein contextawait friend.connect(bob).requestFriend(alice.address); const _list1 = list.slice(); _list1[index].submitting = true; setList(_list1); const tx = await friend.requestFriend(to); const receipt = await tx.wait(); const _list2 = list.slice(); _list2[index].submitting = false; setList(_list2); message.success('Request sent succeed'); //save sent status to local updateLocalFriendApplySentStatus(account, to, true); setApplySent(true); receiveFriendRequest function receiveFriendRequest( address inviter ) examplein contextconst tx = await friend.connect(alice).receiveFriendRequest(bob.address); const tx = await friendContract.receiveFriendRequest(from); const receipt = await tx.wait(); setPassSubmitting(false); message.success('Friend request passed.'); //update local status updateLocalFriendRequestHandleStatus( from, account.toLowerCase(), 1, ); setLocalStatus(1); rejectFriendRequest function rejectFriendRequest( address inviter, bool ifBlock ) examplein contextconst tx = await friend .connect(alice) .rejectFriendRequest(bob.address, false); const tx = await friendContract.rejectFriendRequest(from, false); const receipt = await tx.wait(); setRefuseSubmitting(false); message.success('Friend request refused.'); //update local status updateLocalFriendRequestHandleStatus( from, account.toLowerCase(), 2, ); setLocalStatus(2); blockUser function blockUser( address user ) exampleawait friend.connect(alice).blockUser(bob.address); unblockUser function unblockUser( address user ) exampleawait friend.connect(alice).unblockUser(bob.address); removeFriend function removeFriend( address friend ) examplein contextconst tx = await friend.connect(alice).removeFriend(bob.address); setSubmitting(true); const tx = await friend.removeFriend(address); const recept = await tx.wait(); message.success('Delete friend succeed.'); isFriend function isFriend( address alice, address bob ) exampleconst tx = await friend.connect(alice).isFriend(bob.address); Events FriendRequested event FriendRequested( address sender, address receiver ) Emitted when requestFriend called. Includes the sender and receiver. FriendRequestedWithGift event FriendRequestedWithGift( address sender, uint256 gift, address receiver ) Emitted when requestFriendWithGift called. Includes the sender, gift and the receiver. FriendRequestReceived event FriendRequestReceived( address receiver, address inviter ) Emitted when receiveFriendRequest called. Includes the receiver and inviter. FriendRequestRejected event FriendRequestRejected( address receiver, address inviter ) Emitted when rejectFriendRequest called. Includes the receiver and inviter. UserBlocked event UserBlocked( address blocked, address blockedBy ) Emitted when blockUser called. Includes the blocked user and the sender. UserUnblocked event UserUnblocked( address unblocked, address unblockedBy ) Emitted when unblockUser called. Includes the unblocked user and the sender. FriendRemoved event FriendRemoved( address friend, address removedBy ) Emitted when removeFriend called.Includes the removed friend and the sender. Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 13:53:01 "},"contracts/group-relation.html":{"url":"contracts/group-relation.html","title":"Group Relation","summary":"API reference for Relation Group Contract.","keywords":"","body":"Group Relation Index Methods Name Description createGroup Create a group updateGroupInfo Update Group Information requestGroupManager Request as a group manager receiveGroupManagerRequest Receive a group manager request rejectGroupRequest Reject a group request addGroupManager Add a user as group manager removeGroupManager Remove a group manager addGroupMember Add a user as group member removeGroupMember Remove a user from group removeGroup Remove a group joinGroup Join a group transferGroupOwner Transfer a group to another one isInGroup If a user in group Events Name Description GroupCreated Emitted from a group contract when a group created GroupUpdated Emitted from a group contract when a group updated GroupRemoved Emitted from a group contract when a group removed GroupManagerRequested Emitted from a group contract when a group member request as group manager GroupManagerRequestReceived Emitted from a group contract when a groupmanager received GroupManagerRequestRejected Emitted from a group contract when a groupmanager rejected GroupManagerAdded Emitted from a group contract when a groupmanager added GroupManagerRemoved Emitted from a group contract when a groupmanager removed GroupMemberAdded Emitted from a group contract when a groupmember added GroupMemberJoined Emitted from a group contract when a groupmember joined GroupMemberRemoved Emitted from a group contract when a groupmember removed GroupOwnerTransfered Emitted from a group contract when a groupowner transferred Methods Below you'll find each helper explained in greater detail alongside respective implementation examples to help you leverage these methods once you start building your own relation contract. After the function signature and a short description, two code examples are provided, one focusing on the exact usage of the method and one where the helper is presented in the context of a full contract. createGroup function createGroup( bool joinByUser ) examplein contextawait group.connect(deployer).createGroup(true); setCreating(true); const tx = await group.createGroup( _data.name || '', _data.introduce || '', false, _data.members || [], ); const receipt = await tx.wait(); console.log('createGroup: ', receipt); // save group labels to server const params = { gid: receipt.events[0].args.groupId.toString(), gname: _data.name, labels: [..._data.fixedLabel, ...data.customLabel], }; await createGroupLabels(params); setCreating(false); history.push('/createSuccess'); updateGroupInfo function updateGroupInfo( uint256 groupId, bool _joinByUser ) exampleconst tx = group.connect(deployer).updateGroupInfo(1, false); requestGroupManager function requestGroupManager( uint256 groupId ) exampleawait group.connect(alice).joinGroup(1); const tx = await group.connect(alice).requestGroupManager(1); receiveGroupManagerRequest function receiveGroupManagerRequest( uint256 groupId, address user ) exampleawait group.connect(alice).joinGroup(1); await group.connect(alice).requestGroupManager(1); const tx = await group .connect(deployer) .receiveGroupManagerRequest(1, alice.address); rejectGroupRequest function rejectGroupRequest( uint256 groupId, address user ) exmapleawait group.connect(alice).joinGroup(1); await group.connect(alice).requestGroupManager(1); const tx = await group .connect(deployer) .rejectGroupRequest(1, alice.address); addGroupManager function addGroupManager( uint256 groupId, address manager ) exampleconst tx = group.connect(alice).addGroupMember(1, bob.address); removeGroupManager function removeGroupManager( uint256 groupId, address manager ) exampleconst tx = await group.connect(deployer).addGroupManager(1, alice.address); const tx2 = await group .connect(deployer) .removeGroupManager(1, alice.address); addGroupMember function addGroupMember( uint256 groupId, address user ) examplein contextconst tx = group.connect(deployer).addGroupMember(1, bob.address); const tx = await gruopContract.addGroupMember(groupId, selected); const recept = tx.wait(); setSubmitting(false); message.success('Add group member succeed.'); handleCancel(); removeGroupMember function removeGroupMember( uint256 groupId, address user ) examplein contextconst tx2 = await group.connect(deployer).removeGroupMember(1, bob.address); const tx = await groupContract.removeGroupMember(groupId, user); const recept = await tx.wait(); setSubmitting(false); message.success('Delete member from group succeed.'); const index = members.findIndex((item) => item === user); const _members = members.slice(); _members.splice(index, 1); setMembers(_members); removeGroup function removeGroup( uint256 groupId ) exampleconst tx = group.connect(deployer).removeGroup(1); joinGroup function joinGroup( uint256 groupId ) exampleconst tx = await group.connect(alice).joinGroup(1); transferGroupOwner function transferGroupOwner( uint256 groupId, address newOwner ) exampleconst tx = await group .connect(deployer) .transferGroupOwner(1, alice.address); isInGroup function isInGroup( uint256 groupId ) exampleconst tx = await group.connect(alice).isInGroup(1); Events GroupCreated event GroupCreated( uint256 groupId, address owner ) Emitted when createGroup called. Includes the group id and the group owner. GroupUpdated event GroupUpdated( uint256 groupId, address owner ) Emitted when updateGroupInfo called. Includes the group id and the group owner. GroupRemoved event GroupRemoved( uint256 groupId, address owner ) Emitted when removeGroup called. Includes the group id and the group owner. GroupManagerRequested event GroupManagerRequested( uint256 groupId, address requestedBy ) Emitted when requestGroupManager called. Includes the group id and the user who request the manager. GroupManagerRequestReceived event GroupManagerRequestReceived( uint256 groupId, address requestedBy, address owner ) Emitted when receiveGroupManagerRequest called. Includes the group id and the user who receive the request. GroupManagerRequestRejected event GroupManagerRequestRejected( uint256 groupId, address requestedBy, address owner ) Emitted when rejectGroupRequest called. Includes the group id, the user who request the manager and the owner of the group. GroupManagerAdded event GroupManagerAdded( uint256 groupId, address manager, address owner ) Emitted when addGroupManager called. Includes the group id, new group manager and the owner of the group. GroupManagerRemoved event GroupManagerRemoved( uint256 groupId, address manager, address owner ) Emitted when removeGroupManager called. Includes the group id, removed group manager and the owner of the group. GroupMemberAdded event GroupMemberAdded( uint256 groupId, address member, address addedBy ) Emitted when addGroupMember called. Includes the group id, then added member and who add the member. GroupMemberJoined event GroupMemberJoined( uint256 groupId, address member ) Emitted when joinGroup called. Includes the group id and the joined member. GroupMemberRemoved event GroupMemberRemoved( uint256 groupId, address member, address removedBy ) Emitted when removeGroupMember called. Includes the group id, the removed member and who remove the member. GroupOwnerTransfered event GroupOwnerTransfered( uint256 groupId, address newOwner, address oldOwner ) Emitted when transferGroupOwner called. Includes the group id, new owner and the old owner. Copyright © Relation Netwrok 2019 all right reserved，powered by GitbookModify Time: 2022-01-22 13:58:14 "}}